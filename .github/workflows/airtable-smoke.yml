name: Airtable Smoke Test (Manual)
on: { workflow_dispatch: {} }

jobs:
  run:
    runs-on: ubuntu-latest
    env:
      AIRTABLE_TOKEN:      ${{ secrets.AIRTABLE_TOKEN }}     # your PAT (single line)
      AIRTABLE_API_KEY:    ${{ secrets.AIRTABLE_API_KEY }}   # optional fallback
      AIRTABLE_BASE_ID:    ${{ secrets.AIRTABLE_BASE_ID }}
      AIRTABLE_TABLE_ID:   ${{ secrets.AIRTABLE_TABLE_ID }}  # optional (we’ll use NAME if not set)
      AIRTABLE_TABLE_NAME: ${{ secrets.AIRTABLE_TABLE_NAME }}# you set this one
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: { python-version: '3.11' }
      - name: Install requests
        run: python -m pip install --upgrade pip && python -m pip install requests

      - name: Insert one test record (auto-detect table fields)
        run: |
          python - << 'PY'
          import os, sys, time, json, urllib.parse, requests, string

          BASE   = os.getenv("AIRTABLE_BASE_ID")
          TOKEN  = (os.getenv("AIRTABLE_TOKEN") or os.getenv("AIRTABLE_API_KEY") or "")
          TABLE  = os.getenv("AIRTABLE_TABLE_ID") or os.getenv("AIRTABLE_TABLE_NAME")
          if not (BASE and TOKEN and TABLE):
              sys.exit("Missing AIRTABLE_* envs (need BASE_ID, TOKEN or API_KEY, and TABLE_ID or TABLE_NAME).")

          # Sanitize token
          raw = TOKEN
          TOKEN = TOKEN.strip().replace("\r","").replace("\n","").replace("\t","")
          if any(ch not in string.printable for ch in TOKEN):
              sys.exit("AIRTABLE token contains non-printable characters. Paste a clean one-line token.")
          if TOKEN != raw:
              print("[WARN] Token had whitespace/newlines; sanitized at runtime.")

          H_AUTH = {"Authorization": f"Bearer {TOKEN}"}
          H_JSON = {"Authorization": f"Bearer {TOKEN}", "Content-Type": "application/json"}
          enc_table = urllib.parse.quote(TABLE, safe="")
          create_url = f"https://api.airtable.com/v0/{BASE}/{enc_table}?typecast=true"

          # --- Discover actual field names in the target table ---
          def discover_fields():
              # Prefer schema API (needs schema.bases:read). If forbidden, peek at existing records.
              r = requests.get(f"https://api.airtable.com/v0/meta/bases/{BASE}/tables", headers=H_AUTH, timeout=30)
              if r.status_code == 200:
                  data = r.json()
                  for t in data.get("tables", []):
                      if t.get("id") == TABLE or t.get("name") == TABLE:
                          return [f["name"] for f in t.get("fields", [])]
              # fallback: union keys appearing in up to 5 records
              r = requests.get(f"https://api.airtable.com/v0/{BASE}/{enc_table}?maxRecords=5", headers=H_AUTH, timeout=30)
              if r.status_code == 200:
                  seen = set()
                  for rec in r.json().get("records", []):
                      for k in (rec.get("fields") or {}).keys():
                          seen.add(k)
                  if seen:
                      return sorted(seen)
              return []

          avail = discover_fields()
          print("[SMOKE] Available fields:", avail or "(none detected)")

          # Helpers to choose field names that actually exist
          def pick_one(candidates):
              for cand in candidates:
                  for f in avail:
                      if f.lower() == cand.lower():
                          return f
              for cand in candidates:
                  cl = cand.lower()
                  for f in avail:
                      if cl in f.lower():
                          return f
              return None

          def pick_all(candidates):
              out, seen = [], set()
              for cand in candidates:
                  for f in avail:
                      if f.lower() == cand.lower() and f not in seen:
                          out.append(f); seen.add(f)
              for cand in candidates:
                  cl = cand.lower()
                  for f in avail:
                      if cl in f.lower() and f not in seen:
                          out.append(f); seen.add(f)
              return out

          # Candidate labels we’ll try to match to YOUR columns
          full_name_field  = pick_one(["full_name","Full Name","Name","Full name","fullname","title"])
          cluster_field    = pick_one(["professional_cluster","profession_cluster","professional cluster","Profession Cluster","cluster","Cluster","category","Category","group","Group"])
          occupation_field = pick_one(["occupation","professional_canonical","professional_canonoical","profession","job","role","Role"])
          language_fields  = pick_all(["language","Language","language-origin","Language Origin","lang","Lang"])

          pri
